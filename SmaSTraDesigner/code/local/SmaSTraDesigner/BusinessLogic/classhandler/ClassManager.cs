namespace SmaSTraDesigner.BusinessLogic
{
    using codegeneration.loader;
    using Common;
    using nodes;
    using System;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.IO;
    using System.Linq;
    using System.Windows;

    /// <summary>
    /// Loads and manages node classes from given metadata generated by SmaSTra base library.
    /// </summary>
    public class ClassManager : INotifyPropertyChanged
	{

		#region fields

		/// <summary>
		/// List of all loaded transformations that represent a simple conversion (one input one output).
		/// </summary>
		private Transformation[] baseConversions = null;

		/// <summary>
		/// List of all loaded data sources.
		/// </summary>
		private DataSource[] baseDataSources = null;

		/// <summary>
		/// List of all transformations (that do not fall in the conversion category).
		/// </summary>
		private Transformation[] baseTransformations = null;


        /// <summary>
        /// List of all Combined Nodes.
        /// </summary>
        private CombinedNode[] baseCombinedNodes = null;

        /// <summary>
        /// Dictionary that keeps track of loaded node classes to ensure no ambiguity.
        /// </summary>
        private Dictionary<string, AbstractNodeClass> classes = new Dictionary<string, AbstractNodeClass>();

		/// <summary>
		/// Dictionary that keeps track of loaded data types to ensure no ambiguity.
		/// </summary>
		private Dictionary<string, DataType> dataTypes = new Dictionary<string, DataType>();

		#endregion fields

		#region events

		/// <summary>
		/// Is raised whenever a compatible property changes its value.
		/// </summary>
		public event PropertyChangedEventHandler PropertyChanged;

		#endregion events

		#region properties

		/// <summary>
		/// Gets the BaseConversions instance (creates one if none exists).
		/// List of all loaded transformations that represent a simple conversion (one input one output).
		/// </summary>
		public Transformation[] BaseConversions
		{
			get
			{
				if (this.baseConversions == null)
				{
					this.baseConversions = this.classes.Values.Where(cls => cls.BaseNode is Transformation && cls.InputTypes.Length == 1)
						.Select(cls => (Transformation)cls.BaseNode).ToArray();
				}

				return this.baseConversions;
			}
		}

		/// <summary>
		/// Gets the BaseDataSources instance (creates one if none exists).
		/// List of all loaded data sources.
		/// </summary>
		public DataSource[] BaseDataSources
		{
			get
			{
				if (this.baseDataSources == null)
				{
					this.baseDataSources = this.classes.Values.Where(cls => cls.BaseNode is DataSource)
						.Select(cls => (DataSource)cls.BaseNode).ToArray();
				}

				return this.baseDataSources;
			}
		}

		/// <summary>
		/// Gets the BaseTransformations instance (creates one if none exists).
		/// List of all transformations (that do not fall in the conversion category).
		/// </summary>
		public Transformation[] BaseTransformations
		{
			get
			{
				if (this.baseTransformations == null)
				{
					this.baseTransformations = this.classes.Values.Where(cls => cls.BaseNode is Transformation && cls.InputTypes.Length > 1)
						.Select(cls => (Transformation)cls.BaseNode).ToArray();
				}

				return this.baseTransformations;
			}
		}


        /// <summary>
        /// Gets the Base Combined Nodes instance (creates one if none exists).
        /// List of all Combined Nodes.
        /// </summary>
        public CombinedNode[] BaseCombinedNodes
        {
            get
            {
                if (this.baseCombinedNodes == null)
                {
                    this.baseCombinedNodes = this.classes.Values.Where(cls => cls.BaseNode is CombinedNode)
                        .Select(cls => (CombinedNode)cls.BaseNode).ToArray();
                }

                return this.baseCombinedNodes;
            }
        }

        #endregion properties

        #region methods


        /// <summary>
        /// Adds the Node-Class passed.
        /// </summary>
        /// <param name="nodeClass"> to add. </param>
        /// <returns></returns>
        public AbstractNodeClass AddClass(AbstractNodeClass nodeClass)
        {
            if (nodeClass == null) return null;

            //If already present -> Do not add!
            AbstractNodeClass result;
            if (this.classes.TryGetValue(nodeClass.Name, out result)) return result;

            this.classes.Add(nodeClass.Name, nodeClass);

            // Send property change notifications for appropreate list property, so the GUI can react.
            switch (nodeClass.NodeType)
            {
                case NodeType.Transformation:
                    if (nodeClass.InputTypes.Length == 1)
                    {
                        this.baseConversions = null;
                        this.OnPropertyChanged("BaseConversions");
                    }
                    else
                    {
                        this.baseTransformations = null;
                        this.OnPropertyChanged("TransformationClasses");
                    }
                    break;

                case NodeType.Sensor:
                    this.baseDataSources = null;
                    this.OnPropertyChanged("BaseDataSources");
                    break;

                case NodeType.Combined:
                    this.baseConversions = null;
                    this.OnPropertyChanged("BaseDataConversions");
                    break;
            }

            return nodeClass;
        }

		/// <summary>
		/// Interpret and load a DataType from given name.
		/// </summary>
		/// <param name="dataTypeName"></param>
		/// <returns>Interpreted DataType instance.</returns>
		public DataType AddDataType(string dataTypeName)
		{
			if (String.IsNullOrWhiteSpace(dataTypeName))
			{
				throw new ArgumentException("String argument 'dataTypeName' must not be null or empty (incl. whitespace).", "dataTypeName");
			}

			// Create DataType instance from name if it does not already exist.
			if (!this.dataTypes.ContainsKey(dataTypeName))
			{
				return this.dataTypes[dataTypeName] = new DataType(dataTypeName);
			}

			return this.dataTypes[dataTypeName];
		}

        public DataType[] getDataTypes()
        {
            return dataTypes.Values.ToArray();
        }

		/// <summary>
		/// Load all node classes from a directory path.
		/// </summary>
		/// <param name="path">Directory path containing metadata for node classes to load.</param>
		public void LoadClasses(string path)
		{
			if (!Directory.Exists(path)) return;

            //TEST: New Method:
            NodeLoader loader = Singleton<NodeLoader>.Instance;

            // Subdirectories are presumed to contain a node class each.
            string[] dirs = Directory.GetDirectories(path);
			foreach (string dir in dirs)
			{
                string dirName = Path.GetFileName(dir);

                try
                {
                    AbstractNodeClass loadedClass = loader.loadFromFolder(dir);
                    if (loadedClass == null) throw new Exception("Could not Load Class.... *Mumble... Mumble*");
                    AddClass(loadedClass);
                }catch(Exception exp)
                {
                    MessageBox.Show("Could not load " + dirName + " Error: \n" + exp.Message + "\nSkipping this element.", "Error in loading " + dirName);
                }
			}
		}

        /// <summary>
        /// Gets the First node found with that type name.
        /// Node types should be unique.
        /// Returns null if none found.
        /// </summary>
        /// <param name="typeName">To search.</param>
        /// <returns>The first found node with that name, null if none found.</returns>
        public Node GetNewNodeForType(String typeName)
        {
            Node node = this.BaseConversions
                .Concat<Node>(BaseDataSources)
                .Concat<Node>(BaseTransformations)
                .Concat<Node>(BaseCombinedNodes)
                .FirstOrDefault(x => x.Class.Name == typeName);
            return node == null ? node : (Node)node.Clone();
        }


		/// <summary>
		/// Raises the PropertyChanged event.
		/// </summary>
		/// <param name="propertyName">Name of the property that changed values.</param>
		private void OnPropertyChanged(string propertyName)
		{
			if (this.PropertyChanged != null)
			{
				this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
			}
		}

		#endregion methods

		#region enumerations

		/// <summary>
		/// Possible node types.
		/// </summary>
		public enum NodeType
		{
			Transformation,
			Sensor,
            Combined
		}

		#endregion enumerations
	}
}