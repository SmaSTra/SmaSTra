using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Windows;
using Common;
using SmaSTraDesigner.BusinessLogic.classhandler.nodeclasses;
using SmaSTraDesigner.BusinessLogic.codegeneration.loader;
using SmaSTraDesigner.BusinessLogic.config;
using SmaSTraDesigner.BusinessLogic.nodes;
using SmaSTraDesigner.BusinessLogic.utils;
using SmaSTraDesigner.Controls;
using System.Collections.ObjectModel;

namespace SmaSTraDesigner.BusinessLogic.classhandler
{
    /// <summary>
    /// Loads and manages node classes from given metadata generated by SmaSTra base library.
    /// </summary>
    public class ClassManager : INotifyPropertyChanged
	{

        #region fields

        /// <summary>
        /// Array of one Node of each type.
        /// </summary>
        private List<UcNodeViewer> _allNodeViewers;

        /// <summary>
        /// The Toggle for the DataSources
        /// </summary>
        private bool _toggleDataSources;

        /// <summary>
        /// The Toggle for the Conversions
        /// </summary>
        private bool _toggleConversions;

        /// <summary>
        /// The Toggle for the Transformations
        /// </summary>
        private bool _toggleTransformations;

        /// <summary>
        /// The Toggle for the Basic Elements
        /// </summary>
        private bool _toggleBasic = true;

        /// <summary>
        /// The Toggle for the Custom Elements
        /// </summary>
        private bool _toggleCustom;

        /// <summary>
        /// The Toggle for the Combined Elements
        /// </summary>
        private bool _toggleCombined;

        /// <summary>
        /// The Name to filter for.
        /// </summary>
        private string _filterString = "";


        /// <summary>
        /// The cached filtered Node Classes.
        /// </summary>
        private String[] _filteredNodeClasses;





        /// <summary>
        /// Dictionary that keeps track of loaded node classes to ensure no ambiguity.
        /// </summary>
        private readonly Dictionary<string, AbstractNodeClass> _classes = new Dictionary<string, AbstractNodeClass>();

		#endregion fields

		#region events

		/// <summary>
		/// Is raised whenever a compatible property changes its value.
		/// </summary>
		public event PropertyChangedEventHandler PropertyChanged;

        #endregion events

        #region properties

        /// <summary>
        /// The Array of all Node Classes.
        /// </summary>
        public List<UcNodeViewer> AllNodeViewers
        {
            get
            { if (_allNodeViewers == null) {
                    Node[] allNodes = _classes.Values
                    .Distinct()
                    .Select(n => n.GenerateNode())
                    .NonNull()
                    .OrderBy(s => s.Class.Name)
                    .ToArray();

                    _allNodeViewers = new List<UcNodeViewer>();
                    for (int i = 0; i < allNodes.Length; i++)
                    {
                        
                        Node currentNode = allNodes[i];
                        UcNodeViewer currentViewer;
                        if(currentNode.Class.InputTypes.Count() > 0)
                        {
                            currentViewer = new UcTransformationViewer();
                        } else
                        {
                            currentViewer = new UcDataSourceViewer();
                        }
                        currentViewer.DataContext = currentNode;
                        currentViewer.IsPreview = true;
                        _allNodeViewers.Add(currentViewer);
                    }
                }
                Console.WriteLine("AllNodeViewers");
                return _allNodeViewers;
            }
        }

        /// <summary>
        /// A List of all NodesViewers with 
        /// </summary>
        public List<UcNodeViewer> FilteredNodeViewers
        {
            get
            {
                foreach (UcNodeViewer nodeViewer in AllNodeViewers)
                {
                    nodeViewer.Visibility = FilteredNodeClasses.Contains(nodeViewer.Node.Class.Name) ? Visibility.Visible : Visibility.Collapsed;
                }
                Console.WriteLine("FilteredNodeViewers");
                return AllNodeViewers;
            }
        }

        /// <summary>
        /// The Toggle for the Basic Elements to Bind to the GUI.
        /// </summary>
        public bool ToggleDataSources
        {
            get
            { return _toggleDataSources; }
            set
            {
                this._toggleDataSources = value;
                this._filteredNodeClasses = null;
                this.OnPropertyChanged("FilteredNodeViewers");
            }
        }

        /// <summary>
        /// The Toggle for the Basic Elements to Bind to the GUI.
        /// </summary>
        public bool ToggleConversions
        {
            get
            { return _toggleConversions; }
            set
            {
                this._toggleConversions = value;
                this._filteredNodeClasses = null;
                this.OnPropertyChanged("FilteredNodeViewers");
            }
        }

        /// <summary>
        /// The Toggle for the Basic Elements to Bind to the GUI.
        /// </summary>
        public bool ToggleTransformations
        {
            get
            { return _toggleTransformations; }
            set
            {
                this._toggleTransformations = value;
                this._filteredNodeClasses = null;
                this.OnPropertyChanged("FilteredNodeViewers");
            }
        }

        /// <summary>
        /// The Toggle for the Basic Elements to Bind to the GUI.
        /// </summary>
        public bool ToggleBasic {
            get
            { return _toggleBasic; }
            set
            {
                this._toggleBasic = value;
                this._filteredNodeClasses = null;
                this.OnPropertyChanged("FilteredNodeViewers");
            }
        }


        /// <summary>
        /// The Toggle for the Custom Elements to Bind to the GUI.
        /// </summary>
        public bool ToggleCustom
        {
            get
            { return _toggleCustom; }
            set
            {
                this._toggleCustom = value;
                this._filteredNodeClasses = null;
                this.OnPropertyChanged("FilteredNodeViewers");
            }
        }


        /// <summary>
        /// The Toggle for the Combined Elements to Bind to the GUI.
        /// </summary>
        public bool ToggleCombined
        {
            get
            { return _toggleCombined; }
            set
            {
                this._toggleCombined = value;
                this._filteredNodeClasses = null;
                this.OnPropertyChanged("FilteredNodeViewers");
            }
        }

        /// <summary>
        /// The String to filter the names for to Bind to the GUI.
        /// </summary>
        public string FilterString
        {
            get
            { return _filterString; }
            set
            {
                this._filterString = value.ToLower();
                this._filteredNodeClasses = null;
                this.OnPropertyChanged("FilteredNodeViewers");
            }
        }

        /// <summary>
        /// Gets the Filtered Nodes. To bind to the GUI.
        /// </summary>
        public String[] FilteredNodeClasses
        {
            get
            {
                if (this._filteredNodeClasses != null) return this._filteredNodeClasses;

                Func<AbstractNodeClass, bool> dataSourceFilter = (n => ToggleDataSources || n.InputTypes.Length != 0);
                Func<AbstractNodeClass, bool> conversionFilter = (n => ToggleConversions || n.InputTypes.Length != 1);
                Func<AbstractNodeClass, bool> transformationFilter = (n => ToggleTransformations || n.InputTypes.Length < 2);

                Func<AbstractNodeClass, bool> baseFilter = (n => _toggleBasic || n.UserCreated);
                Func<AbstractNodeClass, bool> customFilter = (n => _toggleCustom || (!n.UserCreated || (n is CombinedNodeClass)));
                Func<AbstractNodeClass, bool> combinedFilter = (n => _toggleCombined || !(n is CombinedNodeClass));

                Func<AbstractNodeClass, bool> blacklistFilter = (n =>  !Singleton<NodeBlacklist>.Instance.IsOnBlackList(n) );
                Func<AbstractNodeClass, bool> nameFilter = (n => string.IsNullOrWhiteSpace(this.FilterString) || n.Name.ToLower().Contains(FilterString));

                //Filter + Generate:
                this._filteredNodeClasses = _classes.Values
                    .Where(dataSourceFilter)
                    .Where(conversionFilter)
                    .Where(transformationFilter)

                    .Where(baseFilter)
                    .Where(customFilter)
                    .Where(combinedFilter)

                    .Where(blacklistFilter)
                    .Where(nameFilter)

                    .Distinct()
                    .Select(n => n.Name)
                    .NonNull()
                    .OrderBy(s => s)
                    .ToArray();

                Console.WriteLine("FilteredNodeClasses");


                return this._filteredNodeClasses;
            }
        }


        #endregion properties

        #region methods


        /// <summary>
        /// Adds the Node-Class passed.
        /// </summary>
        /// <param name="nodeClass"> to add. </param>
        /// <returns></returns>
        public AbstractNodeClass AddClass(AbstractNodeClass nodeClass)
        {
            return AddClass(nodeClass, true);
        }

        private AbstractNodeClass AddClass(AbstractNodeClass nodeClass, bool updateGUI)
        {
            if (nodeClass == null) return null;

            //If already present -> Do not add!
            AbstractNodeClass result;
            if (this._classes.TryGetValue(nodeClass.Name, out result)) return result;

            this._classes.Add(nodeClass.Name, nodeClass);

            //Always update the filtered nodes.
            this._filteredNodeClasses = null;
            _allNodeViewers = null;
            if (updateGUI)
            {
                this.OnPropertyChanged("FilteredNodeClasses");
                this.OnPropertyChanged("FilteredNodeViewers");
            }

            return nodeClass;
        }


        /// <summary>
        /// This reloads everything in the ClassManager.
        /// </summary>
        public void Reload()
        {
            //Clear all the classes already present:
            this._classes.Clear();

            _filteredNodeClasses = null;
            _allNodeViewers = null;

            //Now reload ower folders:
            LoadClasses(Path.Combine(WorkSpace.DIR, WorkSpace.BASE_DIR));
            LoadClasses(Path.Combine(WorkSpace.DIR, WorkSpace.CREATED_DIR));

            this.OnPropertyChanged("FilteredNodeClasses");
            this.OnPropertyChanged("FilteredNodeViewers");

        }


		/// <summary>
		/// Load all node classes from a directory path.
		/// </summary>
		/// <param name="path">Directory path containing metadata for node classes to load.</param>
		public void LoadClasses(string path)
		{
			if (!Directory.Exists(path)) return;

            var loader = Singleton<NodeLoader>.Instance;

            // Subdirectories are presumed to contain a node class each.
            var dirs = Directory.GetDirectories(path);
			foreach (var dir in dirs)
			{
                var dirName = Path.GetFileName(dir);
                try
                {
                    var loadedClass = loader.loadFromFolder(dir);
                    if (loadedClass == null) throw new Exception("Could not Load Class.... *Mumble... Mumble*");
                    AddClass(loadedClass, false);
                }
                catch (FileNotFoundException e)
                {
                    //This is okay, it means there is no Metadata file in the folder.
                    Debug.WriteLine(e.Message);
                }
                catch(Exception exp)
                {
                    MessageBox.Show("Could not load " + dirName + " Error: \n" + exp.Message + "\nSkipping this element.", "Error in loading " + dirName);
                }
			}
		}

        /// <summary>
        /// Gets the First node found with that type name.
        /// Node types should be unique.
        /// Returns null if none found.
        /// </summary>
        /// <param name="typeName">To search.</param>
        /// <returns>The first found node with that name, null if none found.</returns>
        public Node GetNewNodeForType(string typeName)
        {
            var node = GetNodeClassForType(typeName);
            return node?.GenerateNode();
        }

        /// <summary>
        /// Gets the First NodeClass found with that type name.
        /// Returns null if none found.
        /// </summary>
        /// <param name="typeName">To search.</param>
        /// <returns>The first found NodeClass with that name, null if none found.</returns>
        public AbstractNodeClass GetNodeClassForType(string typeName)
        {
            typeName = typeName.Replace(" ", "").Replace("_", "").ToLower();
            return this._classes.Values
                .FirstOrDefault(x => x.Name.Replace(" ", "").Replace("_", "").ToLower() == typeName);
        }


        /// <summary>
        /// Raises the PropertyChanged event.
        /// </summary>
        /// <param name="propertyName">Name of the property that changed values.</param>
        private void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

		#endregion methods

		#region enumerations

		/// <summary>
		/// Possible node types.
		/// </summary>
		public enum NodeType
		{
			Transformation,
			Sensor,
            Combined,
            Buffer
		}

		#endregion enumerations
	}
}