using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Windows;
using Common;
using SmaSTraDesigner.BusinessLogic.classhandler.nodeclasses;
using SmaSTraDesigner.BusinessLogic.codegeneration.loader;
using SmaSTraDesigner.BusinessLogic.config;
using SmaSTraDesigner.BusinessLogic.nodes;
using SmaSTraDesigner.BusinessLogic.utils;

namespace SmaSTraDesigner.BusinessLogic.classhandler
{
    /// <summary>
    /// Loads and manages node classes from given metadata generated by SmaSTra base library.
    /// </summary>
    public class ClassManager : INotifyPropertyChanged
	{

        #region fields

        /// <summary>
        /// The Toggle for the DataSources
        /// </summary>
        private bool _toggleDataSources;

        /// <summary>
        /// The Toggle for the Conversions
        /// </summary>
        private bool _toggleConversions;

        /// <summary>
        /// The Toggle for the Transformations
        /// </summary>
        private bool _toggleTransformations;

        /// <summary>
        /// The Toggle for the Basic Elements
        /// </summary>
        private bool _toggleBasic;

        /// <summary>
        /// The Toggle for the Custom Elements
        /// </summary>
        private bool _toggleCustom;

        /// <summary>
        /// The Toggle for the Combined Elements
        /// </summary>
        private bool _toggleCombined;

        /// <summary>
        /// The Name to filter for.
        /// </summary>
        private string _filterString = "";


        /// <summary>
        /// The cached filtered Nodes.
        /// </summary>
        private Node[] _filteredNodes;





        /// <summary>
        /// Dictionary that keeps track of loaded node classes to ensure no ambiguity.
        /// </summary>
        private readonly Dictionary<string, AbstractNodeClass> _classes = new Dictionary<string, AbstractNodeClass>();

		#endregion fields

		#region events

		/// <summary>
		/// Is raised whenever a compatible property changes its value.
		/// </summary>
		public event PropertyChangedEventHandler PropertyChanged;

        #endregion events

        #region properties

        /// <summary>
        /// The Toggle for the Basic Elements to Bind to the GUI.
        /// </summary>
        public bool ToggleDataSources
        {
            get
            { return _toggleDataSources; }
            set
            {
                this._toggleDataSources = value;
                this._filteredNodes = null;
                this.OnPropertyChanged("FilteredNodes");
            }
        }

        /// <summary>
        /// The Toggle for the Basic Elements to Bind to the GUI.
        /// </summary>
        public bool ToggleConversions
        {
            get
            { return _toggleConversions; }
            set
            {
                this._toggleConversions = value;
                this._filteredNodes = null;
                this.OnPropertyChanged("FilteredNodes");
            }
        }

        /// <summary>
        /// The Toggle for the Basic Elements to Bind to the GUI.
        /// </summary>
        public bool ToggleTransformations
        {
            get
            { return _toggleTransformations; }
            set
            {
                this._toggleTransformations = value;
                this._filteredNodes = null;
                this.OnPropertyChanged("FilteredNodes");
            }
        }

        /// <summary>
        /// The Toggle for the Basic Elements to Bind to the GUI.
        /// </summary>
        public bool ToggleBasic {
            get
            { return _toggleBasic; }
            set
            {
                this._toggleBasic = value;
                this._filteredNodes = null;
                this.OnPropertyChanged("FilteredNodes");
            }
        }


        /// <summary>
        /// The Toggle for the Custom Elements to Bind to the GUI.
        /// </summary>
        public bool ToggleCustom
        {
            get
            { return _toggleCustom; }
            set
            {
                this._toggleCustom = value;
                this._filteredNodes = null;
                this.OnPropertyChanged("FilteredNodes");
            }
        }


        /// <summary>
        /// The Toggle for the Combined Elements to Bind to the GUI.
        /// </summary>
        public bool ToggleCombined
        {
            get
            { return _toggleCombined; }
            set
            {
                this._toggleCombined = value;
                this._filteredNodes = null;
                this.OnPropertyChanged("FilteredNodes");
            }
        }

        /// <summary>
        /// The String to filter the names for to Bind to the GUI.
        /// </summary>
        public string FilterString
        {
            get
            { return _filterString; }
            set
            {
                this._filterString = value.ToLower();
                this._filteredNodes = null;
                this.OnPropertyChanged("FilteredNodes");
            }
        }

        /// <summary>
        /// Gets the Filtered Nodes. To bind to the GUI.
        /// </summary>
        public Node[] FilteredNodes
        {
            get
            {
                if (this._filteredNodes != null) return this._filteredNodes;

                Func<AbstractNodeClass, bool> dataSourceFilter = (n => ToggleDataSources || n.InputTypes.Length != 0);
                Func<AbstractNodeClass, bool> conversionFilter = (n => ToggleConversions || n.InputTypes.Length != 1);
                Func<AbstractNodeClass, bool> transformationFilter = (n => ToggleTransformations || n.InputTypes.Length < 2);

                Func<AbstractNodeClass, bool> baseFilter = (n => _toggleBasic || n.UserCreated);
                Func<AbstractNodeClass, bool> customFilter = (n => _toggleCustom || (!n.UserCreated || (n is CombinedNodeClass)));
                Func<AbstractNodeClass, bool> combinedFilter = (n => _toggleCombined || !(n is CombinedNodeClass));

                Func<AbstractNodeClass, bool> blacklistFilter = (n =>  !Singleton<NodeBlacklist>.Instance.IsOnBlackList(n) );
                Func<AbstractNodeClass, bool> nameFilter = (n => string.IsNullOrWhiteSpace(this.FilterString) || n.Name.ToLower().Contains(FilterString));

                //Filter + Generate:
                return _classes.Values
                    .Where(dataSourceFilter)
                    .Where(conversionFilter)
                    .Where(transformationFilter)

                    .Where(baseFilter)
                    .Where(customFilter)
                    .Where(combinedFilter)

                    .Where(blacklistFilter)
                    .Where(nameFilter)

                    .Distinct()
                    .Select(n => n.GenerateNode())
                    .NonNull()
                    .OrderBy(s => s.Class.Name)
                    .ToArray();
            }
        }


        #endregion properties

        #region methods


        /// <summary>
        /// Adds the Node-Class passed.
        /// </summary>
        /// <param name="nodeClass"> to add. </param>
        /// <returns></returns>
        public AbstractNodeClass AddClass(AbstractNodeClass nodeClass)
        {
            if (nodeClass == null) return null;

            //If already present -> Do not add!
            AbstractNodeClass result;
            if (this._classes.TryGetValue(nodeClass.Name, out result)) return result;

            this._classes.Add(nodeClass.Name, nodeClass);

            //Always update the filtered nodes.
            this._filteredNodes = null;
            this.OnPropertyChanged("FilteredNodes");

            return nodeClass;
        }


        /// <summary>
        /// This reloads everything in the ClassManager.
        /// </summary>
        public void Reload()
        {
            //Clear all the classes already present:
            this._classes.Clear();

            _filteredNodes = null;

            //Now reload ower folders:
            LoadClasses(Path.Combine(WorkSpace.DIR, WorkSpace.BASE_DIR));
            LoadClasses(Path.Combine(WorkSpace.DIR, WorkSpace.CREATED_DIR));


            this.OnPropertyChanged("FilteredNodes");

        }


		/// <summary>
		/// Load all node classes from a directory path.
		/// </summary>
		/// <param name="path">Directory path containing metadata for node classes to load.</param>
		public void LoadClasses(string path)
		{
			if (!Directory.Exists(path)) return;

            var loader = Singleton<NodeLoader>.Instance;

            // Subdirectories are presumed to contain a node class each.
            var dirs = Directory.GetDirectories(path);
			foreach (var dir in dirs)
			{
                var dirName = Path.GetFileName(dir);
                try
                {
                    var loadedClass = loader.loadFromFolder(dir);
                    if (loadedClass == null) throw new Exception("Could not Load Class.... *Mumble... Mumble*");
                    AddClass(loadedClass);
                }
                catch (FileNotFoundException e)
                {
                    //This is okay, it means there is no Metadata file in the folder.
                    Debug.WriteLine(e.Message);
                }
                catch(Exception exp)
                {
                    MessageBox.Show("Could not load " + dirName + " Error: \n" + exp.Message + "\nSkipping this element.", "Error in loading " + dirName);
                }
			}
		}

        /// <summary>
        /// Gets the First node found with that type name.
        /// Node types should be unique.
        /// Returns null if none found.
        /// </summary>
        /// <param name="typeName">To search.</param>
        /// <returns>The first found node with that name, null if none found.</returns>
        public Node GetNewNodeForType(string typeName)
        {
            var node = GetNodeClassForType(typeName);
            return node?.GenerateNode();
        }

        /// <summary>
        /// Gets the First NodeClass found with that type name.
        /// Returns null if none found.
        /// </summary>
        /// <param name="typeName">To search.</param>
        /// <returns>The first found NodeClass with that name, null if none found.</returns>
        public AbstractNodeClass GetNodeClassForType(string typeName)
        {
            typeName = typeName.Replace(" ", "").Replace("_", "").ToLower();
            return this._classes.Values
                .FirstOrDefault(x => x.Name.Replace(" ", "").Replace("_", "").ToLower() == typeName);
        }


        /// <summary>
        /// Raises the PropertyChanged event.
        /// </summary>
        /// <param name="propertyName">Name of the property that changed values.</param>
        private void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

		#endregion methods

		#region enumerations

		/// <summary>
		/// Possible node types.
		/// </summary>
		public enum NodeType
		{
			Transformation,
			Sensor,
            Combined,
            Buffer
		}

		#endregion enumerations
	}
}