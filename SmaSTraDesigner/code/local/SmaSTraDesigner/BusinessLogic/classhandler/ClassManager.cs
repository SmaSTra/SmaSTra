namespace SmaSTraDesigner.BusinessLogic
{
    using classhandler;
    using codegeneration.loader;
    using Common;
    using config;
    using System;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.IO;
    using System.Linq;
    using System.Windows;
    using utils;

    /// <summary>
    /// Loads and manages node classes from given metadata generated by SmaSTra base library.
    /// </summary>
    public class ClassManager : INotifyPropertyChanged
	{

        #region fields

        /// <summary>
        /// The Toggle for the DataSources
        /// </summary>
        private bool toggleDataSources = false;

        /// <summary>
        /// The Toggle for the Conversions
        /// </summary>
        private bool toggleConversions = false;

        /// <summary>
        /// The Toggle for the Transformations
        /// </summary>
        private bool toggleTransformations = false;

        /// <summary>
        /// The Toggle for the Basic Elements
        /// </summary>
        private bool toggleBasic = false;

        /// <summary>
        /// The Toggle for the Custom Elements
        /// </summary>
        private bool toggleCustom = false;

        /// <summary>
        /// The Toggle for the Combined Elements
        /// </summary>
        private bool toggleCombined = false;

        /// <summary>
        /// The Name to filter for.
        /// </summary>
        private string filterString = "";


        /// <summary>
        /// The cached filtered Nodes.
        /// </summary>
        private Node[] filteredNodes = null;





        /// <summary>
        /// Dictionary that keeps track of loaded node classes to ensure no ambiguity.
        /// </summary>
        private Dictionary<string, AbstractNodeClass> classes = new Dictionary<string, AbstractNodeClass>();

		#endregion fields

		#region events

		/// <summary>
		/// Is raised whenever a compatible property changes its value.
		/// </summary>
		public event PropertyChangedEventHandler PropertyChanged;

        #endregion events

        #region properties

        /// <summary>
        /// The Toggle for the Basic Elements to Bind to the GUI.
        /// </summary>
        public bool ToggleDataSources
        {
            get
            { return toggleDataSources; }
            set
            {
                this.toggleDataSources = value;
                this.filteredNodes = null;
                this.OnPropertyChanged("FilteredNodes");
            }
        }

        /// <summary>
        /// The Toggle for the Basic Elements to Bind to the GUI.
        /// </summary>
        public bool ToggleConversions
        {
            get
            { return toggleConversions; }
            set
            {
                this.toggleConversions = value;
                this.filteredNodes = null;
                this.OnPropertyChanged("FilteredNodes");
            }
        }

        /// <summary>
        /// The Toggle for the Basic Elements to Bind to the GUI.
        /// </summary>
        public bool ToggleTransformations
        {
            get
            { return toggleTransformations; }
            set
            {
                this.toggleTransformations = value;
                this.filteredNodes = null;
                this.OnPropertyChanged("FilteredNodes");
            }
        }

        /// <summary>
        /// The Toggle for the Basic Elements to Bind to the GUI.
        /// </summary>
        public bool ToggleBasic {
            get
            { return toggleBasic; }
            set
            {
                this.toggleBasic = value;
                this.filteredNodes = null;
                this.OnPropertyChanged("FilteredNodes");
            }
        }


        /// <summary>
        /// The Toggle for the Custom Elements to Bind to the GUI.
        /// </summary>
        public bool ToggleCustom
        {
            get
            { return toggleCustom; }
            set
            {
                this.toggleCustom = value;
                this.filteredNodes = null;
                this.OnPropertyChanged("FilteredNodes");
            }
        }


        /// <summary>
        /// The Toggle for the Combined Elements to Bind to the GUI.
        /// </summary>
        public bool ToggleCombined
        {
            get
            { return toggleCombined; }
            set
            {
                this.toggleCombined = value;
                this.filteredNodes = null;
                this.OnPropertyChanged("FilteredNodes");
            }
        }

        /// <summary>
        /// The String to filter the names for to Bind to the GUI.
        /// </summary>
        public string FilterString
        {
            get
            { return filterString; }
            set
            {
                this.filterString = value.ToLower();
                this.filteredNodes = null;
                this.OnPropertyChanged("FilteredNodes");
            }
        }

        /// <summary>
        /// Gets the Filtered Nodes. To bind to the GUI.
        /// </summary>
        public Node[] FilteredNodes
        {
            get
            {
                if (this.filteredNodes == null)
                {

                    Func<AbstractNodeClass, bool> dataSourceFilter = (n => { return ToggleDataSources || n.InputTypes.Length != 0; });
                    Func<AbstractNodeClass, bool> conversionFilter = (n => { return ToggleConversions || n.InputTypes.Length != 1; });
                    Func<AbstractNodeClass, bool> transformationFilter = (n => { return ToggleTransformations || n.InputTypes.Length < 2; });

                    Func<AbstractNodeClass, bool> baseFilter = (n => { return toggleBasic || n.UserCreated; });
                    Func<AbstractNodeClass, bool> customFilter = (n => { return toggleCustom || (!n.UserCreated || (n is CombinedNodeClass)); });
                    Func<AbstractNodeClass, bool> combinedFilter = (n => { return toggleCombined || !(n is CombinedNodeClass); });

                    Func<AbstractNodeClass, bool> blacklistFilter = (n =>  !Singleton<NodeBlacklist>.Instance.IsOnBlackList(n) );
                    Func<AbstractNodeClass, bool> nameFilter = (n => { return string.IsNullOrWhiteSpace(this.FilterString) || n.Name.ToLower().Contains(FilterString); });

                    //Filter + Generate:
                    return classes.Values
                        .Where(dataSourceFilter)
                        .Where(conversionFilter)
                        .Where(transformationFilter)

                        .Where(baseFilter)
                        .Where(customFilter)
                        .Where(combinedFilter)

                        .Where(blacklistFilter)
                        .Where(nameFilter)

                        .Distinct()
                        .Select(n => n.generateNode())
                        .NonNull()
                        .OrderBy(s => s.Class.Name)
                        .ToArray();

                }

                return this.filteredNodes;
            }
        }


        #endregion properties

        #region methods


        /// <summary>
        /// Adds the Node-Class passed.
        /// </summary>
        /// <param name="nodeClass"> to add. </param>
        /// <returns></returns>
        public AbstractNodeClass AddClass(AbstractNodeClass nodeClass)
        {
            if (nodeClass == null) return null;

            //If already present -> Do not add!
            AbstractNodeClass result;
            if (this.classes.TryGetValue(nodeClass.Name, out result)) return result;

            this.classes.Add(nodeClass.Name, nodeClass);

            //Always update the filtered nodes.
            if(nodeClass != null)
            {
                this.filteredNodes = null;
                this.OnPropertyChanged("FilteredNodes");
            }

            return nodeClass;
        }


        /// <summary>
        /// This reloads everything in the ClassManager.
        /// </summary>
        public void Reload()
        {
            //Clear all the classes already present:
            this.classes.Clear();

            filteredNodes = null;

            //Now reload ower folders:
            LoadClasses(Path.Combine(WorkSpace.DIR, WorkSpace.BASE_DIR));
            LoadClasses(Path.Combine(WorkSpace.DIR, WorkSpace.CREATED_DIR));


            this.OnPropertyChanged("FilteredNodes");

        }


		/// <summary>
		/// Load all node classes from a directory path.
		/// </summary>
		/// <param name="path">Directory path containing metadata for node classes to load.</param>
		public void LoadClasses(string path)
		{
			if (!Directory.Exists(path)) return;

            //TEST: New Method:
            NodeLoader loader = Singleton<NodeLoader>.Instance;

            // Subdirectories are presumed to contain a node class each.
            string[] dirs = Directory.GetDirectories(path);
			foreach (string dir in dirs)
			{
                string dirName = Path.GetFileName(dir);
                try
                {
                    AbstractNodeClass loadedClass = loader.loadFromFolder(dir);
                    if (loadedClass == null) throw new Exception("Could not Load Class.... *Mumble... Mumble*");
                    AddClass(loadedClass);
                }
                catch (FileNotFoundException e)
                {
                    //This is okay, it means there is no Metadata file in the folder.
                    Debug.WriteLine(e.Message);
                }
                catch(Exception exp)
                {
                    MessageBox.Show("Could not load " + dirName + " Error: \n" + exp.Message + "\nSkipping this element.", "Error in loading " + dirName);
                }
			}
		}

        /// <summary>
        /// Gets the First node found with that type name.
        /// Node types should be unique.
        /// Returns null if none found.
        /// </summary>
        /// <param name="typeName">To search.</param>
        /// <returns>The first found node with that name, null if none found.</returns>
        public Node GetNewNodeForType(String typeName)
        {
            AbstractNodeClass node = GetNodeClassForType(typeName);
            return node == null ? null : node.generateNode();
        }

        /// <summary>
        /// Gets the First NodeClass found with that type name.
        /// Returns null if none found.
        /// </summary>
        /// <param name="typeName">To search.</param>
        /// <returns>The first found NodeClass with that name, null if none found.</returns>
        public AbstractNodeClass GetNodeClassForType(String typeName)
        {
            typeName = typeName.Replace(" ", "").Replace("_", "").ToLower();
            return this.classes.Values
                .FirstOrDefault(x => x.Name.Replace(" ", "").Replace("_", "").ToLower() == typeName);
        }


        /// <summary>
        /// Raises the PropertyChanged event.
        /// </summary>
        /// <param name="propertyName">Name of the property that changed values.</param>
        private void OnPropertyChanged(string propertyName)
		{
			if (this.PropertyChanged != null)
			{
				this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
			}
		}

		#endregion methods

		#region enumerations

		/// <summary>
		/// Possible node types.
		/// </summary>
		public enum NodeType
		{
			Transformation,
			Sensor,
            Combined,
            Buffer
		}

		#endregion enumerations
	}
}